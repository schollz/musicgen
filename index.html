<html>

<head>
    <title>musicgen</title>
    <style>
    :root {
        --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
        --sans-font: -apple-system, BlinkMacSystemFont, 'avenir next', avenir, helvetica, 'helvetica neue', roboto, noto, 'segoe ui', arial, sans-serif
    }

    * {
        /* reset header margines */
        margin: 0;
    }

    body {
        margin: 1em;
    }

    main {
        max-width: 580px;
        margin: 1em auto;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        font-family: var(--sans-font);
    }

    p.text {
        font-size: 4em;
        padding: 0.1em;
    }

    select {
        font-size: 3.5em;
        padding: 0.5em;
        max-width: 90%;
    }
    </style>
</head>

<body>
    <main>
        <p align="center" class="text">midi2midi</p>
        <p align="center" style="padding-top: 1em; padding-bottom: 2em;">
            A midi controller that works in Chrome. <a href="https://github.com/schollz/midi2midi">Source code</a>.
        </p>
        <p align="center" class="text" id="connected">connect</p>
        <div id="connectioninfo">
            <p align="center">
                <select id="controller">
                    <option>X</option>
                </select>
            </p>
            <p align="center" class="text">to</p>
            <p align="center">
                <select id="controllee">
                    <option>Y</option>
                </select>
            </p>
        </div>
    </main>
    <script src="Tone.js"></script>
    <script>
    var midi1 = null;
    var midi2 = null;
    var outputMidi = null;
    var addOption = function(dropdownid, text) {
        var optn = document.createElement("OPTION");
        optn.text = text;
        optn.value = text;
        document.getElementById(dropdownid).options.add(optn);
    }
    var checkOption = function(e) {
        console.log(e);
        if (e.target.id == "controller")
            midi1 = document.getElementById("controller").value;
        if (e.target.id == "controllee")
            midi2 = document.getElementById("controllee").value;
        if (midi1 == midi2) {
            alert("cannot be the same")
            return;
        }
        if (midi1 != null && midi2 != null) {
            console.log("setting up")
            var inputs = midiAccess.inputs.values();
            for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
                if (input.value.name == midi1)
                    input.value.onmidimessage = MIDIMessageEventHandler;
            }
            var outputs = midiAccess.outputs.values();
            for (var output = outputs.next(); output && !output.done; output = outputs.next()) {
                console.log(output);
                if (midi2 == output.value.name)
                    outputMidi = midiAccess.outputs.get(output.value.id);
            }
            document.getElementById("connected").innerText = "connected";
        }
    }
    var midiAccess = null;
    window.addEventListener('load', function() {
        if (navigator.requestMIDIAccess)
            navigator.requestMIDIAccess().then(onMIDIInit, onMIDIReject);
        else {
            document.getElementById("connected").innerText = "No MIDI support present in your browser."
            document.getElementById("connectioninfo").style.display = "none";
            return;
        }
        document.getElementsByTagName('select')[0].onchange = checkOption
        document.getElementsByTagName('select')[1].onchange = checkOption
    });

    function onMIDIInit(midi) {
        midiAccess = midi;
        var haveAtLeastOneDevice = false;
        var inputs = midiAccess.inputs.values();
        for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
            console.log(input);
            addOption("controller", input.value.name)
            haveAtLeastOneDevice = true;
        }
        var outputs = midiAccess.outputs.values();
        for (var output = outputs.next(); output && !output.done; output = outputs.next()) {
            console.log(output);
            addOption("controllee", output.value.name)
        }
        if (!haveAtLeastOneDevice) {
            document.getElementById("connected").innerText = "No MIDI input devices present.";
            document.getElementById("connectioninfo").style.display = "none";
        }
    }

    function onMIDIReject(err) {
        document.getElementById("connected").innerText = "The MIDI system failed to start.";
        document.getElementById("connectioninfo").style.display = "none";
    }

    function MIDIMessageEventHandler(event) {
        // Mask off the lower nibble (MIDI channel, which we don't care about)
        switch (event.data[0] & 0xf0) {
            case 0x90:
                if (event.data[2] != 0) { // if velocity != 0, this is a note-on message
                    noteOn(event.data);
                    return;
                }
                // if velocity == 0, fall thru: it's a note-off.  MIDI's weird, y'all.
            case 0x80:
                noteOff(event.data);
                return;
        }
    }

    function noteOn(e) {
        if (outputMidi != null)
            outputMidi.send(e);
    }

    function noteOff(e) {
        if (outputMidi != null)
            outputMidi.send(e);
    }
    </script>
    <script>
    var masterOffset = 0;

    function NewChord(notePitches, duration, startPosition, loopEvery) {
        var notes = [];
        for (var i = 0; i < notePitches.length; i++) {
            notes.push(NewNote(notePitches[i], duration, startPosition, loopEvery));
        }
        return notes;
    }

    function NewNote(notePitch, duration, startPosition, loopEvery) {
        var note = new Tone.Event(function(time, pitch) {
            synth.triggerAttack([pitch], time);
            console.log(pitch + "on", time);
            var noteend = new Tone.Event(function(time, pitch) {
                console.log(pitch + "off", time)
                synth.triggerRelease([pitch], time)
            }, pitch);
            noteend.set({
                "loop": false
            })

            // subtract off a 32nd note so that other notes have time to use the note
            noteend.start(time + Tone.Time(duration).toSeconds() - masterOffset - Tone.Time("16n").toSeconds());
        }, notePitch);
        note.set({
            "loop": true,
            "loopEnd": loopEvery,
            "humanize": true,
            "probability": 0.8,
        });
        note.start(startPosition);
        return note;
    }


    var chord1 = NewChord(["C4", "E4", "G4"], "1n", 0, "2m");
    var chord2 = NewChord(["B4", "E4", "G4"], "1n", "1m", "2m");

    var note1 = NewNote("C5", "2n", 0, "2m");
    var note2 = NewNote("B4", "2n", "2n", "2m");
    var note2 = NewNote("A4", "2n", "1m", "2m");

    var synth = new Tone.PolySynth(6, Tone.Synth, {
        oscillator: {
            type: "sine"
        },
    }).set({
        "filter": {
            "type": "highpass"
        },
        "envelope": {
            "attack": 0.6,
            "sustain": 0.6,
            "decay": 1,
            "release": 1,
        },
    }).toMaster();

    Tone.Transport.bpm.value = 60;
    masterOffset = Tone.now();
    Tone.Transport.start();
    </script>
</body>

</html>